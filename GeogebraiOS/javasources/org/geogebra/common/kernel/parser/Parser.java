/* Generated By:JavaCC: Do not edit this line. Parser.java */
package org.geogebra.common.kernel.parser;

import org.geogebra.common.kernel.Construction;
import org.geogebra.common.kernel.arithmetic.*;
import org.geogebra.common.kernel.arithmetic3D.MyVec3DNode;
import org.geogebra.common.kernel.arithmetic3D.Vector3DValue;
import org.geogebra.common.kernel.commands.Commands;
import org.geogebra.common.kernel.geos.GeoCasCell;
import org.geogebra.common.kernel.geos.GeoElement;
import org.geogebra.common.kernel.geos.GeoElementSpreadsheet;
import org.geogebra.common.kernel.geos.GeoFunctionNVar;
import org.geogebra.common.kernel.geos.GeoNumeric;
import org.geogebra.common.kernel.geos.GeoVec2D;
import org.geogebra.common.kernel.parser.ParserInterface;
import org.geogebra.common.kernel.StringTemplate;
import org.geogebra.common.main.MyError;
import org.geogebra.common.main.Localization;
import org.geogebra.common.main.MyParseError;
import org.geogebra.common.main.BracketsError;
import org.geogebra.common.util.StringUtil;
import org.geogebra.common.util.Unicode;
import org.geogebra.common.util.debug.Log;
import org.geogebra.common.kernel.Kernel;
import org.geogebra.common.kernel.parser.cashandlers.CommandDispatcherGiac;
import org.geogebra.common.main.App;
import org.geogebra.common.plugin.Operation;

import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Vector;


public class Parser implements ParserInterface, ParserConstants {

    private Kernel kernel;
    private App app;
    private Localization loc;
    private boolean GeoGebraCASParsing = false;
    private boolean ExternalCASParsing = false;
  private boolean GiacParsing = false;
  private ArrayList<ExpressionNode > undecided = new ArrayList<ExpressionNode >();

    public Parser(Kernel kernel, Construction cons) {
       this ( new java.io.StringReader("") ); // dummy stream for parser initing
         this.kernel = kernel;
         app = kernel.getApplication();
         loc = app.getLocalization();
    }

    public Kernel getKernel()
    {
      return kernel;
    }

    // reset for new parsing
    public void myReInit(String parseString) throws ParseException {
        if(!kernel.getConstruction().isFileLoading() && StringUtil.checkBracketsBackward(StringUtil.ignoreIndices(parseString))>=0){
          throw new BracketsError(loc,parseString);
        }
      ReInit(new java.io.StringReader(StringUtil.fixVerticalBars(parseString)));
      GeoGebraCASParsing = false;
      ExternalCASParsing = false;
      GiacParsing = false;
      undecided.clear();
    }

    /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraExpression(String parseString) throws ParseException {
        myReInit( parseString.charAt(0)=='=' ? parseString.substring(1):parseString );
        ValidExpression ret = buildValidExpression();
        processUndecided();
        return ret;
    }

     /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraCAS(String parseString, GeoCasCell cell) throws ParseException {
        myReInit( parseString );
        // parse x^2 + y^2 as an expression and don't throw Incomplete Equation error
        GeoGebraCASParsing = true;
        ValidExpression ret = buildCASExpression(cell);
        return ret;
    }

    /**
     * Parses a Giac String and returns a ValidExpression Object     
     */
    public ValidExpression parseGiac(String parseString) throws ParseException {
        myReInit( parseString );
        ExternalCASParsing = true;
        GiacParsing = true;
        return buildGiacExpression();
    }

    /**
     * Parses a String and returns a Function Object     
     */
    public Function parseFunction(String parseString)
    throws ParseException {
        myReInit( parseString );
        Function ret = function();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String and returns a Function Object     
     */
    public FunctionNVar parseFunctionNVar(String parseString)
    throws ParseException {
        myReInit( parseString );
        FunctionNVar ret = functionNVar();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseCmdExpression(String parseString)
    throws ParseException {
        myReInit(parseString );
        ExpressionNode ret = cmdexpression();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseExpression(String parseString)
    throws ParseException {
        myReInit( parseString);
        ExpressionNode ret = expression();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String if it is a label
     */
    public String parseLabel(String parseString)
    throws ParseException {
        myReInit(parseString );
        return label().image;
    }
    private ExpressionNode makePower(ExpressionValue v,ExpressionValue e){
      if(v.isExpressionNode() && ((ExpressionNode)v).getOperation()
        ==Operation.MULTIPLY_OR_FUNCTION && !((ExpressionNode)v).hasBrackets()){
        return new ExpressionNode(kernel,((ExpressionNode)v).getLeft(),Operation.MULTIPLY,
          new ExpressionNode(kernel,((ExpressionNode)v).getRight(),Operation.POWER,e));
      }
      return new ExpressionNode(kernel,v,Operation.POWER,e);
  }

  private void processUndecided(){
    for(ExpressionNode en: undecided)
      en.setOperation(Operation.MULTIPLY);
    undecided.clear();
   }

   private ExpressionNode buildOpNode(Operation op,MyList list){
     switch(list.size())
     {
       case 1:return new ExpressionNode(kernel,list.getListElement(0),op,null);
       case 2:return new ExpressionNode(kernel,list.getListElement(0),op,list.getListElement(1));
       //for beta regularized
       case 3:return new ExpressionNode(kernel,new MyNumberPair(kernel,list.getListElement(0),
       list.getListElement(1)),op,list.getListElement(2));
       //for sum (from CAS)
       case 4:return new ExpressionNode(kernel,new MyNumberPair(kernel,list.getListElement(0),
       list.getListElement(1)),op,new MyNumberPair(kernel,list.getListElement(2),
       list.getListElement(3)));
       default:return null;
     }
   }

/**
 * for GeoGebra input field
 * validexpression =    
 *                  labellist() = command() |           // e.g. {A,B} = Intersect[c, g]
 *                      <LABEL> : parametric() |        // e.g. X = (3,2) + t (2,1)              
 *                      <LABEL> = expression()      // arithmetic expression of floats, vectors and vars
 *                      <LABEL> : equation()        // equation in x an y
             <LABEL>(x) = function()   // function in x, e.g. f(x) = 3x^3 - sqrt(x)
 */
  final public ValidExpression buildValidExpression() throws ParseException {
    ValidExpression ve = null;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Token c = null;
    Vector labels = new Vector();
    if (jj_2_1(2147483647)) {
      ve = functionExpressionnode();
    } else if (jj_2_2(3)) {
      ve = spreadsheetRange();
    } else if (jj_2_3(2147483647)) {
      l = label();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 70:
        jj_consume_token(70);
        break;
      case ASSIGNMENT:
        jj_consume_token(ASSIGNMENT);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ve = equation();
    } else if (jj_2_4(2147483647)) {
      l = label();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 70:
        jj_consume_token(70);
        break;
      case ASSIGNMENT:
        jj_consume_token(ASSIGNMENT);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ve = cmdexpression();
    } else if (jj_2_5(2147483647)) {
      lhs = expressionnode();
      jj_consume_token(EQUAL);
      rhs = expressionnode();
            // maybe it's an assignment, i.e. there is no x, y, or z on the right side
      if (!rhs.containsFreeFunctionVariable(null))
      {
          // assignment, e.g. z = 23
          if (lhs.isSingleVariable()) {
                  ve = rhs;
                  ve.setLabel(((Variable)lhs.evaluate(StringTemplate.defaultTemplate)).getName(StringTemplate.defaultTemplate));
              }

        // special case: e = 2 should be an assignment
        // but an undefined "e" has been read as the Euler constant already
        else if (Unicode.EULER_STRING.equals(lhs.toString(StringTemplate.defaultTemplate)))
        {
           ve = rhs;
                    ve.setLabel("e");
        }

        // special case: i = 2 should be an assignment
        // but an undefined "i" has been read as the imaginary unit already
        else if (lhs.isImaginaryUnit())
        {
            ve = rhs;
                    ve.setLabel("i");
        }

        // special case: z = 2 should be an assignment when 3D view is not present
        else if (kernel.isZvarAllowed() && "z".equals(lhs.toString(StringTemplate.defaultTemplate)))
        {
          ve = rhs;
                  ve.setLabel("z");
        }
      }

      // standard equation
      if (ve == null) {
                // it's an equation in x, y, and possibly z
                ve = new Equation(kernel, lhs, rhs);
            }
    } else if (jj_2_6(2147483647)) {
      ve = cmdexpression();
    } else if (jj_2_7(2147483647)) {
      labels = labellist();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        jj_consume_token(EQUAL);
        break;
      case ASSIGNMENT:
        jj_consume_token(ASSIGNMENT);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ve = command();
    } else if (jj_2_8(2147483647)) {
      ve = cartesianvector_special();
    } else if (jj_2_9(2147483647)) {
      ve = cartesianvector3D_special();
    } else if (jj_2_10(2147483647)) {
      ve = polarvector_special();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POLAR_SEPARATOR:
      jj_consume_token(POLAR_SEPARATOR);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (labels.size() > 0) ve.addLabel(labels);  // command with ouput labels
        else if (ve.labelCount() == 0)
        {
          ve.addLabel(l.image);  // standard case
        }
        {if (true) return ve;}
    throw new Error("Missing return statement in function");
  }

/**
 *  parse GeoGebra CAS input
 */
  final public ValidExpression buildCASExpression(GeoCasCell cell) throws ParseException {
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Token assign = null;
    Token c= null;
    Token c2 =null;
    Vector labels = new Vector();
    if (jj_2_11(2147483647)) {
      ve = casFunction(cell);
    } else if (jj_2_12(2147483647)) {
      l = label();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 70:
        assign = jj_consume_token(70);
        break;
      case ASSIGNMENT:
        assign = jj_consume_token(ASSIGNMENT);
        break;
      case DELAYED_ASSIGNMENT:
        assign = jj_consume_token(DELAYED_ASSIGNMENT);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ve = equation();
    } else if (jj_2_13(2147483647)) {
      l = casVar();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 70:
        assign = jj_consume_token(70);
        break;
      case ASSIGNMENT:
        assign = jj_consume_token(ASSIGNMENT);
        break;
      case DELAYED_ASSIGNMENT:
        assign = jj_consume_token(DELAYED_ASSIGNMENT);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ve = expressionnode();
    } else if (jj_2_14(2147483647)) {
      ve = equation();
    } else if (jj_2_15(2147483647)) {
      ve = expressionnode();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POLAR_SEPARATOR:
      jj_consume_token(POLAR_SEPARATOR);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      // remember label      
      if (l.image != null)
      {
          if(":".equals(assign.image) &&
          GeoElementSpreadsheet.isSpreadsheetLabel(ve.toString(StringTemplate.defaultTemplate)))
          {
            ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, l.image));
    ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, ve.toString(StringTemplate.defaultTemplate)));
    Command cmd = new Command(kernel, "CellRange", false, !ExternalCASParsing ); // don't translate name
    cmd.addArgument(startCell);
    cmd.addArgument(endCell);
    {if (true) return cmd;}
          }
          ve.addLabel(l.image);
          if(cell != null){
                cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
          }
       }
        {if (true) return ve;}
    throw new Error("Missing return statement in function");
  }

/**
 * convert MathPiper String to GeoGebra string
 */
  final public ValidExpression buildMathPiperExpression() throws ParseException {
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Vector labels = new Vector();
    // try to parse MathPiper string as standard GeoGebra expression 
          ve = buildCASExpression(null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POLAR_SEPARATOR:
      jj_consume_token(POLAR_SEPARATOR);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return ve;}
    throw new Error("Missing return statement in function");
  }

  final private ValidExpression buildGiacExpression() throws ParseException {
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Vector labels = new Vector();
    // try to parse Giac string as standard GeoGebra expression 
          ve = buildCASExpression(null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POLAR_SEPARATOR:
      jj_consume_token(POLAR_SEPARATOR);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return ve;}
    throw new Error("Missing return statement in function");
  }

/**
 * convert Maxima String to GeoGebra string
 */
  final public ValidExpression buildMaximaExpression() throws ParseException {
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token start,sign = null,end;
    // try to parse Maxima string as standard GeoGebra expression 
          ve = buildCASExpression(null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POLAR_SEPARATOR:
      jj_consume_token(POLAR_SEPARATOR);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return ve;}
    throw new Error("Missing return statement in function");
  }

/**
 * (<VARZ> | <LABEL> | <SPREADSHEET_LABEL>) 
 */
  final public Token label() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARZ:
      t = jj_consume_token(VARZ);
      break;
    case SPREADSHEET_LABEL:
      t = jj_consume_token(SPREADSHEET_LABEL);
      break;
    case LABEL:
      t = jj_consume_token(LABEL);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
           {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * (<VARX> | <VARY> | <VARZ> | <LABEL> | <SPREADSHEET_LABEL>) 
 */
  final public Token casVar() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARX:
      t = jj_consume_token(VARX);
      break;
    case VARY:
      t = jj_consume_token(VARY);
      break;
    case VARZ:
      t = jj_consume_token(VARZ);
      break;
    case LABEL:
      t = jj_consume_token(LABEL);
      break;
    case SPREADSHEET_LABEL:
      t = jj_consume_token(SPREADSHEET_LABEL);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * command =     <LABEL> [ argument (, argument)* ]  
 */
  final public ValidExpression command() throws ParseException {
    Command c;
    Token t;
    String cmdName;
    ExpressionNode en;
    t = jj_consume_token(FUNCTION_LABEL);
        cmdName = t.image.substring(0,t.image.length()-1);
        c = new Command(kernel, cmdName, true, !ExternalCASParsing );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VERTICAL_BAR:
    case NOT:
    case PLUS:
    case MINUS:
    case FACTORIAL:
    case UNDEFINED:
    case PI:
    case EULER_GAMMA:
    case E:
    case IMAGINARY:
    case DEGREE:
    case INFINITY:
    case RAD:
    case TRUE:
    case FALSE:
    case VARX:
    case VARY:
    case VARZ:
    case FLOAT:
    case EFLOAT:
    case PERCENTAGE:
    case SPREADSHEET_LABEL:
    case LABEL:
    case X_FUNC:
    case Y_FUNC:
    case Z_FUNC:
    case RANDOM_FUNC:
    case SQRT_SHORT:
    case FUNCTION_LABEL:
    case FUNCTION_POWER_LABEL:
    case TEXT:
    case 73:
    case 75:
      en = cmdexpression();
                                    c.addArgument( en );
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_1;
      }
      jj_consume_token(COMMA);
      en = cmdexpression();
                                           c.addArgument( en );
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 71:
      jj_consume_token(71);
      break;
    case 72:
      jj_consume_token(72);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (GiacParsing)
      {
        ExpressionNode res = CommandDispatcherGiac.processCommand(cmdName,c,kernel);
        if (res != null)
          {if (true) return res;}
      }
      {if (true) return c;}
    throw new Error("Missing return statement in function");
  }

/**
 * labellist =    { <LABEL> (, <LABEL>)* }  
 */
  final public Vector labellist() throws ParseException {
    Token t;
    Vector labels;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 73:
      jj_consume_token(73);
      t = label();
            labels = new Vector(); labels.add(t.image);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        t = label();
                               labels.add(t.image);
      }
      jj_consume_token(74);
      break;
    case VARZ:
    case SPREADSHEET_LABEL:
    case LABEL:
      t = label();
            labels = new Vector(); labels.add(t.image);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        t = label();
                               labels.add(t.image);
      }
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
       {if (true) return labels;}
    throw new Error("Missing return statement in function");
  }

/** NOT USED BY NOW
 * normalvectorform =   <PARAMETRICVAR> vector  = vector 
 
NormalVectorForm normalvectorform():
{         
    ExpressionNode left, right;
    ExpressionValue temp;
}
{    
    <PARAMETRICVAR> (<MULTIPLY>)? left = enterm()  <EQUAL> right = expressionnode()           
         {                        
            // check if left is VectorValue and right is NumberValue
            temp = left.evaluate();
            if (!(temp instanceof VectorValue)) {
                String [] str = { "VectorExpected", temp.toString() };
                throw new MyParseError(loc, str);
            }

            temp = right.evaluate();
            if (!(temp instanceof NumberValue)) {
                String [] str = { "NumberExpected", temp.toString() };
                throw new MyParseError(loc, str);
            }        
            
            return new NormalVectorForm( left, right );                
         }   
}
*/

/******************************************************************
 * ARTIHMETIC FOR NUMBERS AND 2D VECTORS WITH VARIABLES
 * plus
 * ARTIHMETIC FOR POLYNOMIALS WITH VARIABLES "x" AND "y"
 * exponents must be integers >= 0
 * divisors must be simplifyable to numbers
 ******************************************************************/


/**
 * equation =       expression = expression
 */
  final public Equation equation() throws ParseException {
    ExpressionNode lhs, rhs;
    lhs = expressionnode();
    jj_consume_token(EQUAL);
    rhs = expressionnode();
            {if (true) return new Equation(kernel, lhs, rhs);}
    throw new Error("Missing return statement in function");
  }

/**
 * expression = expressionnode
 */
  final public ExpressionNode expression() throws ParseException {
    ExpressionNode rhs;
    rhs = expressionnode();
      // Giac uses x,y not ggbtmpvarx/y
        if (!GeoGebraCASParsing && !GiacParsing && rhs.containsFreeFunctionVariable(null)) {
          {if (true) throw new MyError(loc, "IncompleteEquation");}
        }

        // since v3.0: commands have to take care of resolving the variables of 
        // their arguments on their own, e.g. Sequence[ (i, i^2), i , 1, 10 ]       
    //rhs.resolveVariables();
        {if (true) return rhs;}
    throw new Error("Missing return statement in function");
  }

/**
 * cmdexpression = expressionnode 
 * (may only return Function)
 */
  final public ExpressionNode cmdexpression() throws ParseException {
    ExpressionNode en;
    en = expressionOrEquation();
        // since v3.0: commands have to take care of resolving the variables of 
        // their arguments on their own, e.g. Sequence[ (i, i^2), i , 1, 10 ]       
    //rhs.resolveVariables();
        {if (true) return en;}
    throw new Error("Missing return statement in function");
  }

/**
 * function = functionExpressionnode 
 */
  final public Function function() throws ParseException {
    ExpressionNode rhs;
    Token l = null;
    Function f;
    // f(x) =  x^2 + 3  
          rhs = functionExpressionnode();
        if (rhs.getLeft() instanceof Function) {
          f = (Function) rhs.getLeft();
        }
        else {
            f = new Function(rhs);
        }
        f.setLabel(rhs.getLabel());
        {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

/**
 * functionNVar = functionExpressionnode 
 */
  final public FunctionNVar functionNVar() throws ParseException {
    ExpressionNode rhs;
    Token l = null;
    FunctionNVar f;
    // f(x) =  x^2 + 3  
          rhs = functionExpressionnode();
        if (rhs.getLeft() instanceof FunctionNVar) {
          f = (FunctionNVar) rhs.getLeft();
        }
        else {
            f = new FunctionNVar(rhs);
        }
        f.setLabel(rhs.getLabel());
        {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

/**
 * function =   f(var1, var2) = expressionnode 
 *        f(var) := expressionnode 
 *        f(var) = command
 */
  final public ExpressionNode functionExpressionnode() throws ParseException {
    ExpressionNode rhs;
    ExpressionNode condition= null;
    Token funName = null;
    Token varName = null;
    ArrayList<String> localVars;
    Token var;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FUNCTION_LABEL:
      funName = jj_consume_token(FUNCTION_LABEL);
      break;
    case Z_FUNC:
      // includes "(" at end
             funName = jj_consume_token(Z_FUNC);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARX:
      varName = jj_consume_token(VARX);
      break;
    case VARY:
      varName = jj_consume_token(VARY);
      break;
    case VARZ:
    case SPREADSHEET_LABEL:
    case LABEL:
      varName = label();
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
             localVars = new ArrayList<String>(); localVars.add(varName.image);
           kernel.getConstruction().registerFunctionVariable(varName.image);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      varName = casVar();
         localVars.add(varName.image);
       kernel.getConstruction().registerFunctionVariable(varName.image);
    }
    jj_consume_token(71);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      break;
    case ASSIGNMENT:
      jj_consume_token(ASSIGNMENT);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    rhs = expressionnode();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      condition = expressionnode();
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
          // allow f(y) in CAS but not in GeoGebra
    //  if (!ExternalCASParsing && !GeoGebraCASParsing && "y".equals(varName.image)) 
      //      throw new MyError(app, "InvalidInput");
        if(condition != null)
        {
                        rhs = new ExpressionNode(kernel, condition, Operation.IF, rhs);
        }
        String funLabel = funName.image.substring(0,funName.image.length()-1);

      // command without variables: return expressionnode
      // only check for function variables outside of command, eg Derivative[f(x)]+x #4533
        if (rhs.getLeft() instanceof Command && !rhs.containsFreeFunctionVariable(null)) {
        rhs.setLabel(funLabel);
        {if (true) return rhs;}
      }


        // function: wrap function in ExpressionNode
      // number of vars
      int n = localVars.size();
      Operation op = app.getParserFunctions().get(funLabel,n);
      if(op!=null)
      {
        if(n==1)
        {
          {if (true) return new Equation(kernel,new FunctionVariable(kernel,localVars.get(0)).wrap().apply(op),rhs).wrap();}
        }
        MyList vars = new MyList(kernel, n);
        for (int i=0;i<n; i++){
          FunctionVariable funVar = new FunctionVariable(kernel,localVars.get(i));
          vars.addListElement(funVar);
        }
        {if (true) return new Equation(kernel,vars.wrap(),rhs).wrap();}
      }

      FunctionVariable[] funVar = new FunctionVariable[n];
        for (int i=0;i<n; i++){
          funVar[i] = new FunctionVariable(kernel);
          funVar[i].setVarString(localVars.get(i));
        }

          switch (n) {
            case 1: // single variable function          
        Function fun = new Function(rhs, funVar[0]);
        fun.setLabel(funLabel);
        rhs = new ExpressionNode(kernel, fun);
        break;

             default: // multi variable function
             FunctionNVar funn = new FunctionNVar(rhs, funVar);
        funn.setLabel(funLabel);
        rhs = new ExpressionNode(kernel, funn);
             break;
          }

           rhs.setLabel(funLabel);
           {if (true) return rhs;}
    throw new Error("Missing return statement in function");
  }

/**
 * CAS function =   label(var) := expressionnode 
 */
  final public FunctionNVar casFunction(GeoCasCell cell) throws ParseException {
    ExpressionNode rhs;
    Token funName = null;
    Token varName = null;
    Token assign = null;
    ArrayList<String> localVars;
    Token var;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FUNCTION_LABEL:
      funName = jj_consume_token(FUNCTION_LABEL);
      break;
    case Z_FUNC:
      // includes "(" at end
             funName = jj_consume_token(Z_FUNC);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    varName = casVar();
             localVars = new ArrayList<String>(); localVars.add(varName.image);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      varName = casVar();
         localVars.add(varName.image);
    }
    jj_consume_token(71);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGNMENT:
      assign = jj_consume_token(ASSIGNMENT);
      break;
    case DELAYED_ASSIGNMENT:
      assign = jj_consume_token(DELAYED_ASSIGNMENT);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    rhs = expressionnode();
        String funLabel = funName.image.substring(0,funName.image.length()-1);

      // number of vars
      int n = localVars.size();

      FunctionVariable[] funVar = new FunctionVariable[n];
        for (int i=0;i<n; i++){
          funVar[i] = new FunctionVariable(kernel);
          funVar[i].setVarString(localVars.get(i));
        }

          switch (n) {
            case 1: // single variable function          
        Function fun = new Function(rhs, funVar[0]);
        fun.setLabel(funLabel);
        if(cell != null){
                cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
        }
        {if (true) return fun;}

             default: // multi variable function
             FunctionNVar funn = new FunctionNVar(rhs, funVar);
        funn.setLabel(funLabel);
        if(cell != null){
                cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
        }
        {if (true) return funn;}
          }
    throw new Error("Missing return statement in function");
  }

/**
 *  expression =  term <OR> term
 */
  final public ExpressionNode expressionnode() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = ORterm();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLICATION:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_6;
      }
      jj_consume_token(IMPLICATION);
      f = ORterm();
           ret = new ExpressionNode(kernel, ret, Operation.IMPLICATION, f);
    }
      ExpressionNode en;
      if (ret.isExpressionNode())
        en = (ExpressionNode) ret;
      else
        en = new ExpressionNode(kernel, ret);

      //en.expandEquationExpressions();
      if (ExternalCASParsing)
        en.simplifyLeafs();
      {if (true) return en;}
    throw new Error("Missing return statement in function");
  }

/**
 *  expressionOrEquation =  equation | expressionnode 
 */
  final public ExpressionNode expressionOrEquation() throws ParseException {
    ExpressionNode en, rhs;
    en = expressionnode();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      rhs = expressionnode();
              en = new ExpressionNode(kernel, new Equation(kernel, en, rhs));
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    {if (true) return en;}
    throw new Error("Missing return statement in function");
  }

/**
 * ANDterm =   COMPAREterm <AND> COMPAREterm 
 */
  final public ExpressionValue ANDterm() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = COMPAREterm();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      f = COMPAREterm();
          ret = new ExpressionNode(kernel, ret, Operation.AND, f);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * ORterm =   ANDterm <OR> ANDterm 
 */
  final public ExpressionValue ORterm() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = ANDterm();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_8;
      }
      jj_consume_token(OR);
      f = ANDterm();
          ret = new ExpressionNode(kernel, ret, Operation.OR, f);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * COMPAREterm =   listopnode ("==" | "<" | "<=" | ">" | ">=") listopnode 
 */
  final public ExpressionValue COMPAREterm() throws ParseException {
    ExpressionValue left, right;
    ExpressionNode result;
    Vector<ExpressionNode> andList = null;
    left = listopnode();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL_BOOLEAN:
      case NOT_EQUAL:
      case IS_SUBSET_OF:
      case IS_SUBSET_OF_STRICT:
      case LESS:
      case GREATER:
      case LESS_EQUAL:
      case GREATER_EQUAL:
      case PARALLEL:
      case PERPENDICULAR:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL_BOOLEAN:
        jj_consume_token(EQUAL_BOOLEAN);
        right = listopnode();
         if (ExternalCASParsing)
             result = new ExpressionNode(kernel, new Equation(kernel, left, right));
         else
                result = new ExpressionNode(kernel, left, Operation.EQUAL_BOOLEAN, right);
        break;
      case NOT_EQUAL:
        jj_consume_token(NOT_EQUAL);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.NOT_EQUAL, right);
        break;
      case IS_SUBSET_OF:
        jj_consume_token(IS_SUBSET_OF);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF, right);
        break;
      case IS_SUBSET_OF_STRICT:
        jj_consume_token(IS_SUBSET_OF_STRICT);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF_STRICT, right);
        break;
      case LESS:
        jj_consume_token(LESS);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.LESS, right);
        break;
      case GREATER:
        jj_consume_token(GREATER);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.GREATER, right);
        break;
      case LESS_EQUAL:
        jj_consume_token(LESS_EQUAL);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.LESS_EQUAL, right);
        break;
      case GREATER_EQUAL:
        jj_consume_token(GREATER_EQUAL);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.GREATER_EQUAL, right);
        break;
      case PARALLEL:
        jj_consume_token(PARALLEL);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.PARALLEL, right);
        break;
      case PERPENDICULAR:
        jj_consume_token(PERPENDICULAR);
        right = listopnode();
           result = new ExpressionNode(kernel, left, Operation.PERPENDICULAR, right);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        // store all AND parts
        // e.g. 3 < x < 7 should get stored as 3 < x && x < 7
        if (andList == null)
      andList = new Vector<ExpressionNode>();
    andList.add(result);
    left = right;
    }
      if (andList != null) {
      // build AND ExpressionNode tree, e.g. 3 < x && x < 7
        left = andList.get(0);
        for (int i=1; i < andList.size(); i++) {
      left = new ExpressionNode(kernel, left, Operation.AND_INTERVAL, andList.get(i));
        }
      }
      {if (true) return left;}
    throw new Error("Missing return statement in function");
  }

/**
 *  expression =    term + term |
 *                  term - term
 */
  final public ExpressionValue plusminusnode() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = multterm();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        x = jj_consume_token(PLUS);
        break;
      case MINUS:
        x = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      f = multterm();
            if (x.kind == PLUS)
                ret = new ExpressionNode(kernel, ret, Operation.PLUS, f);
            else
                ret = new ExpressionNode(kernel, ret, Operation.MINUS, f);
    }
      //ret.simplifyLeafs();
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionValue setdifferencenode() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = plusminusnode();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SET_DIFFERENCE:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_11;
      }
      jj_consume_token(SET_DIFFERENCE);
      f = plusminusnode();
            ret = new ExpressionNode(kernel, ret, Operation.SET_DIFFERENCE, f);
    }
      //ret.simplifyLeafs();
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionValue listopnode() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = setdifferencenode();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IS_ELEMENT_OF:
      jj_consume_token(IS_ELEMENT_OF);
      f = setdifferencenode();
            ret = new ExpressionNode(kernel, ret, Operation.IS_ELEMENT_OF, f);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
      //ret.simplifyLeafs();
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * multterm =   divterm * divterm 
 */
  final public ExpressionValue multterm() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = divterm();
    label_12:
    while (true) {
      if (jj_2_16(1)) {
        ;
      } else {
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case VECTORPRODUCT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
          x = jj_consume_token(MULTIPLY);
          break;
        case VECTORPRODUCT:
          x = jj_consume_token(VECTORPRODUCT);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        f = divterm();
            if (x.kind == MULTIPLY) {
                ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);
            } else {
                ret = new ExpressionNode(kernel, ret, Operation.VECTORPRODUCT, f);
            }
        break;
      default:
        jj_la1[37] = jj_gen;
        if (getToken(1).kind != VERTICAL_BAR) {
          f = powerdivterm();
              ExpressionValue special = ExpressionNode.multiplySpecial(ret, f, kernel, GiacParsing);

                  if(special == null)
                  {
                      ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);
                  }else {
                          ret = special;
                  }
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * divterm =  unary / unary
 */
  final public ExpressionValue divterm() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = enunary();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIVIDE:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_13;
      }
      jj_consume_token(DIVIDE);
      f = enunary();
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * powerdivterm =  power / unary
 */
  final public ExpressionValue powerdivterm() throws ParseException {
    ExpressionValue ret, f;
    Token x;
    ret = enpower();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIVIDE:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_14;
      }
      jj_consume_token(DIVIDE);
      f = enunary();
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * unary =  -power    |
 *           +power    |   
 *          power
 */
  final public ExpressionValue enunary() throws ParseException {
    ExpressionValue e;
    Token c;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
      jj_consume_token(MINUS);
      e = enpower();
          // -e  = -1*e
          {if (true) return new ExpressionNode(kernel, new MyDouble(kernel, -1.0d), Operation.MULTIPLY, e);}
      break;
    case PLUS:
      jj_consume_token(PLUS);
      e = enpower();
          // +e  = e
          {if (true) return e;}
      break;
    case VERTICAL_BAR:
    case NOT:
    case FACTORIAL:
    case UNDEFINED:
    case PI:
    case EULER_GAMMA:
    case E:
    case IMAGINARY:
    case DEGREE:
    case INFINITY:
    case RAD:
    case TRUE:
    case FALSE:
    case VARX:
    case VARY:
    case VARZ:
    case FLOAT:
    case EFLOAT:
    case PERCENTAGE:
    case SPREADSHEET_LABEL:
    case LABEL:
    case X_FUNC:
    case Y_FUNC:
    case Z_FUNC:
    case RANDOM_FUNC:
    case SQRT_SHORT:
    case FUNCTION_LABEL:
    case FUNCTION_POWER_LABEL:
    case TEXT:
    case 73:
    case 75:
      e = enpower();
            {if (true) return e;}
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * power =    element                 |
 *          element ^ power           
 */
  final public ExpressionValue enpower() throws ParseException {
    ExpressionValue ret, f;
    Token c = null;
    ArrayList<ExpressionValue> exponentList = null;
    ret = enfactorial();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POWER:
      case POWERN:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POWERN:
        c = jj_consume_token(POWERN);
            f = new MyDouble(kernel, c.image);
            // collect exponents
      if (exponentList == null)
        exponentList = new ArrayList<ExpressionValue>();
            exponentList.add(f);
        break;
      case POWER:
        jj_consume_token(POWER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUS:
            c = jj_consume_token(MINUS);
            break;
          case PLUS:
            c = jj_consume_token(PLUS);
            break;
          default:
            jj_la1[42] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
        }
        f = enfactorial();
            // -f  = -1*f
      if (c != null && c.kind == MINUS)
      {
             f = new ExpressionNode(kernel, new MyDouble(kernel, -1.0d), Operation.MULTIPLY, f);
             c = null; // make sure we forget minus for next exponent
            }

      // collect exponents
      if (exponentList == null)
        exponentList = new ArrayList<ExpressionValue>();
            exponentList.add(f);

           /*
          // check if we have e^
          if (ret.isExpressionNode()) {
            ExpressionNode en = (ExpressionNode) ret;
            if (en.isLeaf() &&  en.getLeft() instanceof MyDouble) {
              MyDouble num = (MyDouble) en.getLeft();
              if (num.getDouble() == Math.E) {        
                  ret = new ExpressionNode(kernel, f, Operation.EXP, null);            
              } 
            }       
          }
      */

        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if (exponentList == null)
      {if (true) return ret;}


      // GeoGebra / Giac etc : right associative: a^b^c = a^(b^c)
      int size = exponentList.size();
      ExpressionValue tempEV = exponentList.get(size-1); // last exponent, e.g. c
      for (int i=size-2; i >= 0; i--)
    {
      ExpressionValue prevExponent = exponentList.get(i);
      tempEV = makePower(prevExponent,tempEV);
    }
    ret = makePower(ret, tempEV);

        {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * factorial =  <NOTterm> |
 *              <NOTterm> !
 */
  final public ExpressionValue enfactorial() throws ParseException {
    ExpressionValue en;
    en = ensqrt();
    if (jj_2_17(2147483647)) {
      jj_consume_token(FACTORIAL);
             if(en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION
             && !((ExpressionNode)en).hasBrackets())
             {
               en = new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(),
                 Operation.MULTIPLY,
                 new ExpressionNode(kernel, ((ExpressionNode)en).getRight(), Operation.FACTORIAL, null)
                 );
             }
             else
              en = new ExpressionNode(kernel, en, Operation.FACTORIAL, null);
    } else {
      ;
    }
         {if (true) return en;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionValue ensqrt() throws ParseException {
    ExpressionValue en;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQRT_SHORT:
      jj_consume_token(SQRT_SHORT);
      en = NOTterm();
             if(en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION
             && !((ExpressionNode)en).hasBrackets())
             {
               en = new ExpressionNode(kernel,
               new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(), Operation.SQRT_SHORT, null),
                 Operation.MULTIPLY,
               ((ExpressionNode)en).getRight()
                 );
             }
             else
              en = new ExpressionNode(kernel, en, Operation.SQRT_SHORT, null);
              {if (true) return en;}
      break;
    case VERTICAL_BAR:
    case NOT:
    case FACTORIAL:
    case UNDEFINED:
    case PI:
    case EULER_GAMMA:
    case E:
    case IMAGINARY:
    case DEGREE:
    case INFINITY:
    case RAD:
    case TRUE:
    case FALSE:
    case VARX:
    case VARY:
    case VARZ:
    case FLOAT:
    case EFLOAT:
    case PERCENTAGE:
    case SPREADSHEET_LABEL:
    case LABEL:
    case X_FUNC:
    case Y_FUNC:
    case Z_FUNC:
    case RANDOM_FUNC:
    case FUNCTION_LABEL:
    case FUNCTION_POWER_LABEL:
    case TEXT:
    case 73:
    case 75:
      en = NOTterm();
         {if (true) return en;}
         {if (true) return en;}
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * NOTterm =  <NOT> <enelement> |
 *                 <enelement>
 */
  final public ExpressionValue NOTterm() throws ParseException {
    ExpressionValue en;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
    case FACTORIAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
        break;
      case FACTORIAL:
        jj_consume_token(FACTORIAL);
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      en = enelement();
              {if (true) return new ExpressionNode(kernel, en, Operation.NOT, null);}
      break;
    case VERTICAL_BAR:
    case UNDEFINED:
    case PI:
    case EULER_GAMMA:
    case E:
    case IMAGINARY:
    case DEGREE:
    case INFINITY:
    case RAD:
    case TRUE:
    case FALSE:
    case VARX:
    case VARY:
    case VARZ:
    case FLOAT:
    case EFLOAT:
    case PERCENTAGE:
    case SPREADSHEET_LABEL:
    case LABEL:
    case X_FUNC:
    case Y_FUNC:
    case Z_FUNC:
    case RANDOM_FUNC:
    case FUNCTION_LABEL:
    case FUNCTION_POWER_LABEL:
    case TEXT:
    case 73:
    case 75:
      en = enelement();
         {if (true) return en;}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * element =    <variable>      |
 *              <float>         |
 *              ( expression )
 */
  final public ExpressionValue enelement() throws ParseException {
    ExpressionValue ev;
    double num;
    Token c;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
     {if (true) return  new MyBoolean(kernel, true);}
      break;
    case FALSE:
      jj_consume_token(FALSE);
      {if (true) return new MyBoolean(kernel, false);}
      break;
    case UNDEFINED:
    case PI:
    case EULER_GAMMA:
    case E:
    case IMAGINARY:
    case DEGREE:
    case INFINITY:
    case RAD:
    case FLOAT:
    case EFLOAT:
    case PERCENTAGE:
      // number
          ev = myDouble();
          {if (true) return ev;}
      break;
    default:
      jj_la1[48] = jj_gen;
      if (jj_2_18(2147483647)) {
        ev = numberFunction();
           {if (true) return ev;}
      } else if (jj_2_19(2147483647)) {
        ev = command();
          {if (true) return ev;}
      } else if (jj_2_20(2147483647)) {
        ev = numVecVariable();
          {if (true) return ev;}
      } else if (jj_2_21(2147483647)) {
        ev = list();
        {if (true) return ev;}
      } else if (jj_2_22(2147483647)) {
        jj_consume_token(75);
        ev = expressionOrEquation();
        jj_consume_token(71);
          ev = ev.unwrap(); if(ev instanceof ExpressionNode)
        {
          ((ExpressionNode)ev).setBrackets(true);
        }
        {if (true) return ev;}
      } else if (jj_2_23(2147483647)) {
        jj_consume_token(VERTICAL_BAR);
        ev = expressionnode();
        jj_consume_token(VERTICAL_BAR);
                        {if (true) return new ExpressionNode(kernel, ev, Operation.ABS, null);}
      } else if (jj_2_24(2147483647)) {
        ev = cartesianvector();
          {if (true) return ev;}
      } else if (jj_2_25(2147483647)) {
        ev = cartesianvector3D();
          {if (true) return ev;}
      } else if (jj_2_26(2147483647)) {
        ev = polarvector();
          {if (true) return ev;}
      } else if (jj_2_27(2147483647)) {
        ev = sphericalvector();
          {if (true) return ev;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TEXT:
          // text (between " ... ")
            c = jj_consume_token(TEXT);
      // remove " (first and last character)
      String text = c.image.substring(1, c.image.length()-1);
      {if (true) return  new MyStringBuffer(kernel, text);}
          break;
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionValue list() throws ParseException {
    MyList myList;
    ExpressionValue ev;
    if (jj_2_28(5)) {
      jj_consume_token(73);
      jj_consume_token(74);
           {if (true) return new MyList(kernel);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 73:
        jj_consume_token(73);
        ev = cmdexpression();
            myList = new MyList(kernel);
            myList.addListElement(ev);
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[50] = jj_gen;
            break label_16;
          }
          jj_consume_token(COMMA);
          ev = cmdexpression();
           myList.addListElement(ev);
        }
        jj_consume_token(74);
       {if (true) return myList;}
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionValue numVecVariable() throws ParseException {
    GeoElement geo;
    Token c;
    ExpressionValue ev;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARX:
      c = jj_consume_token(VARX);
        if (GeoGebraCASParsing)
       {if (true) return new Variable(kernel, c.image);}
    else
          {if (true) return new FunctionVariable(kernel, c.image);}
      break;
    case VARY:
      c = jj_consume_token(VARY);
        if (GeoGebraCASParsing)
       {if (true) return new Variable(kernel, c.image);}
    else
          {if (true) return new FunctionVariable(kernel, c.image);}
      break;
    case VARZ:
      c = jj_consume_token(VARZ);
        // check for CAS parsing or if z is defined in kernel
        if (GeoGebraCASParsing || kernel.lookupLabel("z") != null) {
       {if (true) return new Variable(kernel, c.image);}
    } else {
       // z is not defined: treat as equation variable for 3D view
        {if (true) return new FunctionVariable(kernel, c.image);}
       }
      break;
    default:
      jj_la1[53] = jj_gen;
      if (jj_2_29(3)) {
        ev = spreadsheetRange();
    {if (true) return ev;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPREADSHEET_LABEL:
        case LABEL:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPREADSHEET_LABEL:
            c = jj_consume_token(SPREADSHEET_LABEL);
            break;
          case LABEL:
            c = jj_consume_token(LABEL);
            break;
          default:
            jj_la1[52] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        // should we read e for Euler constant and i for imaginary unit?
    boolean lookforEulerImaginary = false;

    if (GeoGebraCASParsing)
    {
        // leave e and i untouched in GeoGebraCAS view
        lookforEulerImaginary = false;
    }
    else if (ExternalCASParsing)
    {  // Giac does not need it either, may need changing for other CASes
        lookforEulerImaginary = false;
    }
    else
    {   // GeoGebraCAS or GeoGebra parsing
      // only treat e or i specially when they are undefined in GeoGebra
      lookforEulerImaginary = true;
    }

        // return defined variables immediately
    if (lookforEulerImaginary)
    {
      // TREAT e and i specially
      // e for Euler constant
      if (c.image.equals("e") && kernel.lookupLabel(c.image) == null)
      {
        {if (true) return MySpecialDouble.getEulerConstant(kernel);}
      }
      // i for imaginary unit
      else if (c.image.equals("i") && kernel.lookupLabel(c.image) == null)
      {
          {if (true) return kernel.getImaginaryUnit();}
      }
    }

       // standard case for variables
       {if (true) return new Variable(kernel, c.image);}
          break;
        default:
          jj_la1[54] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * spreadsheet range, e.g. A3:B5
 */
  final public Command spreadsheetRange() throws ParseException {
    Token c, c2;
    // spreadsheet range like A1:B2
      c = jj_consume_token(SPREADSHEET_LABEL);
    jj_consume_token(70);
    c2 = jj_consume_token(SPREADSHEET_LABEL);
    // build command CellRange[ startCell, endCell ]
    ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, c.image));
    ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, c2.image));
    Command cmd = new Command(kernel, "CellRange", false, !ExternalCASParsing ); // don't translate name
    cmd.addArgument(startCell);
    cmd.addArgument(endCell);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

/**
 * floating point number: angle or numeric are distinguished
 */
  final public ExpressionValue myDouble() throws ParseException {
    Token c;
    MyDouble d;
    double val;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
    case EFLOAT:
    case PERCENTAGE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
      case EFLOAT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FLOAT:
          c = jj_consume_token(FLOAT);
          break;
        case EFLOAT:
          c = jj_consume_token(EFLOAT);
          break;
        default:
          jj_la1[55] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      // check if token includes "b"

          c.image = c.image.replaceFirst("e", "E" );
        val = MyDouble.parseDouble( loc, c.image );
        break;
      case PERCENTAGE:
        c = jj_consume_token(PERCENTAGE);
        val = MyDouble.parsePercentage( loc, c.image );
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (ExternalCASParsing || GeoGebraCASParsing) {
        // preserve string from CAS: it may have higher
        // precision than double
           {if (true) return new MySpecialDouble(kernel, val, c.image);}
      }
      else {
          {if (true) return new MyDouble(kernel, val);}
      }
      break;
    case DEGREE:
      jj_consume_token(DEGREE);
       // constant for degree to radians 
        d = new MySpecialDouble(kernel, Math.PI / 180.0d, "\u00b0");
        d.setAngle();
        {if (true) return d;}
      break;
    case RAD:
      jj_consume_token(RAD);
       // constant for radians to radians 
        d = new MySpecialDouble(kernel, 1.0d, "rad");
        d.setAngle();
        {if (true) return d;}
      break;
    case PI:
      jj_consume_token(PI);
         {if (true) return new MySpecialDouble(kernel, Math.PI, Unicode.PI_STRING);}
      break;
    case EULER_GAMMA:
      jj_consume_token(EULER_GAMMA);
         {if (true) return new MySpecialDouble(kernel, 0.57721566490153286, Unicode.EULER_GAMMA_STRING);}
      break;
    case E:
      jj_consume_token(E);
      {if (true) return new MySpecialDouble(kernel, Math.E, Unicode.EULER_STRING);}
      break;
    case IMAGINARY:
      jj_consume_token(IMAGINARY);
      GeoVec2D z = new GeoVec2D(kernel, 0, 1);
      z.setMode(Kernel.COORD_COMPLEX);
      {if (true) return z;}
      break;
    case INFINITY:
      jj_consume_token(INFINITY);
        {if (true) return new MyDouble(kernel, Double.POSITIVE_INFINITY);}
      break;
    case UNDEFINED:
      jj_consume_token(UNDEFINED);
        {if (true) return new MyDouble(kernel, Double.NaN);}
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * mathematical Function (cos, sin, tan, ...)
 */
  final public ExpressionNode numberFunction() throws ParseException {
    ExpressionNode en, en2, en3,en4;
    ExpressionValue ev;
    MyList myList;
    Token c, flabel, fvar1, fvar2;
    String conslabel;
    MySpecialDouble myconst;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case X_FUNC:
      c = jj_consume_token(X_FUNC);
      en = expressionOrEquation();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 71:
        jj_consume_token(71);
        break;
      case 72:
        jj_consume_token(72);
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if (GeoGebraCASParsing)
        {
                {if (true) return Command.xyzCAS(en, 0,!ExternalCASParsing, undecided);}
        }
        else
        {
          // standard GeoGebra input bar: x(...) is interpreted as "x-coordinate of"
          {if (true) return new ExpressionNode(kernel, en, Operation.XCOORD, null);}
        }
      break;
    case Y_FUNC:
      c = jj_consume_token(Y_FUNC);
      en = expressionOrEquation();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 71:
        jj_consume_token(71);
        break;
      case 72:
        jj_consume_token(72);
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if (GeoGebraCASParsing)
        {
            // GeoGebra CAS view: y(...) is interpreted as a function
            {if (true) return Command.xyzCAS(en, 1,!ExternalCASParsing, undecided);}
        }
        else
        {
          // standard GeoGebra input bar: y(...) is interpreted as "y-coordinate of"
          {if (true) return new ExpressionNode(kernel, en, Operation.YCOORD, null);}
        }
      break;
    case Z_FUNC:
      c = jj_consume_token(Z_FUNC);
      en = expressionOrEquation();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 71:
        jj_consume_token(71);
        break;
      case 72:
        jj_consume_token(72);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if (GeoGebraCASParsing)
        {
            {if (true) return Command.xyzCAS(en,2,!ExternalCASParsing, undecided);}
        }
        else
        {
            // standard GeoGebra input bar: z(...) is interpreted as user function z or "z-coordinate of"
              GeoElement userFun = kernel.lookupLabel("z");
       if (userFun instanceof Evaluatable) {
          // user defined function z
        {if (true) return new ExpressionNode(kernel, userFun, Operation.FUNCTION, en);}
            } else {
         // internal function z
        {if (true) return new ExpressionNode(kernel, en, Operation.ZCOORD, null);}
           }
        }
      break;
    case FUNCTION_POWER_LABEL:
      c = jj_consume_token(FUNCTION_POWER_LABEL);
      en = expressionOrEquation();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 71:
        jj_consume_token(71);
        break;
      case 72:
        jj_consume_token(72);
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
             int pos = c.image.length()-2;
             while(pos >=0 && (Unicode.isSuperscriptDigit(c.image.charAt(pos))||
             Unicode.Superscript_Minus==c.image.charAt(pos))){
               pos--;
             }
             ExpressionNode ret = kernel.handleTrigPower(c.image, en, c.image.substring(0,pos+1));
             if(ret.getOperation()==Operation.MULTIPLY_OR_FUNCTION)
               undecided.add(ret);
             {if (true) return ret;}
      break;
    case RANDOM_FUNC:
      jj_consume_token(RANDOM_FUNC);
         Construction cons = kernel.getConstruction();
         GeoNumeric randNum = new GeoNumeric(cons);
         cons.addRandomGeo(randNum);
         randNum.setValue(app.getRandomNumber());
         {if (true) return new ExpressionNode(kernel, randNum, Operation.RANDOM, null);}
      break;
    case FUNCTION_LABEL:
      c = jj_consume_token(FUNCTION_LABEL);
      en = expressionOrEquation();
            myList = new MyList(kernel, true);
            myList.addListElement(en);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[62] = jj_gen;
          break label_17;
        }
        jj_consume_token(COMMA);
        en = expressionOrEquation();
           myList.addListElement(en);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 71:
        jj_consume_token(71);
        break;
      case 72:
        jj_consume_token(72);
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          // remove the opening parenthesis
          String funcName = c.image.substring(0, c.image.length()-1);

      if (GiacParsing)  {
          // check for special Giac functions, e.g. diff, Psi etc.
        en = CommandDispatcherGiac.processCommand(funcName, myList, kernel);
        if (en != null)
        {
          {if (true) return en;}
        }
        }
      boolean forceCommand = c.image.charAt(c.image.length()-1)=='[';
      GeoElement geo = null;
          GeoElement cell = null;
      // check for derivative using f'' notation
          int order = 0;
          int index = funcName.length()-1;
      String label = funcName;
      if(!forceCommand){

            geo = kernel.lookupLabel(funcName);
            cell = kernel.lookupCasCellLabel(funcName);

            if (cell==null && (geo == null || !(geo.isGeoFunction() || geo.isGeoCurveCartesian())))  {
                if(label.startsWith("log_"))
                {
                        String logIndex = label.substring(4);
                        if(logIndex.startsWith("{"))
                        {
                                                logIndex = logIndex.substring(1,logIndex.length() -1);
                        }
                        double indexVal = MyDouble.parseDouble(loc, logIndex);

                                        {if (true) return new ExpressionNode(kernel, new MyDouble(kernel, indexVal), Operation.LOGB, myList.getListElement(0));}
                }
                while (index >=0 && c.image.charAt(index) == '\u005c''){
                    order++;
                  index--;
               }

              while (index < funcName.length()) {
                label = funcName.substring(0, index+1);
                geo = kernel.lookupLabel(label);
                cell = kernel.lookupCasCellLabel(label);
                // stop if f' is defined but f is not defined, see #1444
                if (cell!=null ||
                (geo != null && (geo.isGeoFunction() || geo.isGeoCurveCartesian()))) {
                    break;
                }

                order--;
                index++;
              }
            }

            //f(t)=t(t+1)
            if(kernel.getConstruction().isRegistredFunctionVariable(funcName)){
              ExpressionNode expr =  new ExpressionNode(kernel, new Variable(kernel,funcName), Operation.MULTIPLY_OR_FUNCTION, myList.getListElement(0));
              undecided.add(expr);
              {if (true) return expr;}
            }

        }

          if (forceCommand || (geo == null && cell==null)) {
                Operation op = app.getParserFunctions().get(funcName,myList.size());
                if(op!=null)
                  {if (true) return buildOpNode(op,myList);}
              // function name does not exist: return command
              Command cmd = new Command(kernel, funcName, true, !ExternalCASParsing );
              for (int i=0; i < myList.size(); i++)
              {
                cmd.addArgument((ExpressionNode) myList.getListElement(i));
              }
              {if (true) return new ExpressionNode(kernel, cmd);}

//              String [] str = { "UndefinedVariable", funcName };
//                throw new MyParseError(loc, str);    
             }
             //make sure we don't send 0th derivative to CAS
      if(cell!=null && order > 0)  {

             ExpressionNode derivative =  new ExpressionNode(kernel, cell, Operation.DERIVATIVE,
                                        new MyDouble(kernel, order));

            {if (true) return new ExpressionNode(kernel, derivative, Operation.FUNCTION, myList.getListElement(0));}

        }
        //f(t):=(t,t) produces line, we do not want CAS to use that line
        //Perhaps we should prefer cell over geo in all cases ?
        if(cell!=null && (geo==null || geo.isGeoLine() || geo.isGeoConic()))  {
          if(((GeoCasCell)cell).getFunctionVariables().length <2)
          {

            {if (true) return new ExpressionNode(kernel, cell, Operation.FUNCTION, myList.getListElement(0));}
        }else
        {
        {if (true) return new ExpressionNode(kernel, cell, Operation.FUNCTION_NVAR, myList);}
        }

        }
      // create variable object for label to make sure
      // to handle lables like $A$1 correctly and keep the expression
      Variable geoVar = new Variable(kernel, label);
      ExpressionValue geoExp = geoVar.resolveAsExpressionValue();

      // numer of arguments
      int argNumber = myList.size();

          if (order > 0) { // derivative
                        // n-th derivative of geo
            ExpressionNode derivative =  new ExpressionNode(kernel, geoExp, Operation.DERIVATIVE,
                                        new MyDouble(kernel, order));
            if (geo.isGeoFunction()) {// function 
              {if (true) return new ExpressionNode(kernel, derivative, Operation.FUNCTION, myList.getListElement(0));}
            }
            else if (geo.isGeoCurveCartesian()) {// Cartesian curve 
              {if (true) return new ExpressionNode(kernel, derivative, Operation.VEC_FUNCTION, myList.getListElement(0));}
            }
            else {
                  String [] str = { "FunctionExpected", funcName };
                  {if (true) throw new MyParseError(loc, str);}
            }
          }
          else { // no derivative: a(b)
            if (geo instanceof Evaluatable) // function 
              {if (true) return new ExpressionNode(kernel, geoExp, Operation.FUNCTION, myList.getListElement(0));}
        else if (geo instanceof GeoFunctionNVar) {
          {if (true) return new ExpressionNode(kernel, geoExp, Operation.FUNCTION_NVAR, myList);}
        }
            else if (geo.isGeoCurveCartesian()) // vector function
            // at this point we have eg myList={{1,2}}, so we need first element of myList                    
              {if (true) return new ExpressionNode(kernel, geoExp, Operation.VEC_FUNCTION, myList.getListElement(0));}

        // disabled, see #1115
        // doesn't work properly, creates spurious geos
            else if (geo.isGeoList()) // list1(1) to get first element of list1
            {
          //return new ExpressionNode(kernel, geoExp, Operation.ELEMENT_OF, myList); 
              String [] str = { "FunctionExpected", funcName };
                  {if (true) throw new MyParseError(loc, str);}
        }
        // a(b) becomes a*b because a is not a function, no list, and no curve
        // e.g. a(1+x) = a*(1+x) when a is a number             
            ExpressionNode expr =  new ExpressionNode(kernel, geoExp, Operation.MULTIPLY_OR_FUNCTION, myList.getListElement(0));
            undecided.add(expr);
            {if (true) return expr;}

//            else {// error: no function
//              String [] str = { "FunctionExpected", funcName };
//                  throw new MyParseError(loc, str);
//              }
          }
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * cartesianvector =  ( expression, expression ) 
 */
  final public VectorValue cartesianvector() throws ParseException {
    ExpressionValue x, y;
    if (jj_2_30(2147483647)) {
      jj_consume_token(75);
      x = expression();
      jj_consume_token(COMMA);
      y = expression();
      jj_consume_token(71);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 75:
        jj_consume_token(75);
        x = expression();
        jj_consume_token(VERTICAL_BAR);
        y = expression();
        jj_consume_token(71);
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
           {if (true) return new MyVecNode(kernel, x, y);}
    throw new Error("Missing return statement in function");
  }

/**
 * cartesianvector3D =  ( expression, expression ) 
 */
  final public Vector3DValue cartesianvector3D() throws ParseException {
    ExpressionValue x, y, z;
    if (jj_2_31(2147483647)) {
      jj_consume_token(75);
      x = expression();
      jj_consume_token(COMMA);
      y = expression();
      jj_consume_token(COMMA);
      z = expression();
      jj_consume_token(71);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 75:
        jj_consume_token(75);
        x = expression();
        jj_consume_token(VERTICAL_BAR);
        y = expression();
        jj_consume_token(VERTICAL_BAR);
        z = expression();
        jj_consume_token(71);
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
           {if (true) return new MyVec3DNode(kernel, x, y, z);}
    throw new Error("Missing return statement in function");
  }

/**
 * polarvector = ( expression ; expression )             
 */
  final public VectorValue polarvector() throws ParseException {
    ExpressionValue r, phi;
    MyVecNode v;
    jj_consume_token(75);
    r = expression();
    jj_consume_token(POLAR_SEPARATOR);
    phi = expression();
    jj_consume_token(71);
             v = new MyVecNode(kernel);
             v.setPolarCoords(r, phi);
             {if (true) return v;}
    throw new Error("Missing return statement in function");
  }

/**
 * sphericalvector = ( expression ; expression ; expression )             
 */
  final public Vector3DValue sphericalvector() throws ParseException {
    ExpressionValue r, phi, theta;
    MyVec3DNode v;
    jj_consume_token(75);
    r = expression();
    jj_consume_token(POLAR_SEPARATOR);
    theta = expression();
    jj_consume_token(POLAR_SEPARATOR);
    phi = expression();
    jj_consume_token(71);
             v = new MyVec3DNode(kernel);
             v.setSphericalPolarCoords(r, theta, phi);
             {if (true) return v;}
    throw new Error("Missing return statement in function");
  }

/**
 * cartesianvector_special =  <LABEL>( expression | expression ) 
 */
  final public ExpressionNode cartesianvector_special() throws ParseException {
   Token l;
    ExpressionValue x, y;
    l = jj_consume_token(FUNCTION_LABEL);
    x = expression();
    jj_consume_token(VERTICAL_BAR);
    y = expression();
    jj_consume_token(71);
          ExpressionNode en =  new ExpressionNode(kernel, new MyVecNode(kernel, x, y));
          en.setLabel(l.image.substring(0,l.image.length()-1));
          {if (true) return en;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode cartesianvector3D_special() throws ParseException {
   Token l;
    ExpressionValue x, y, z;
    l = jj_consume_token(FUNCTION_LABEL);
    x = expression();
    jj_consume_token(VERTICAL_BAR);
    y = expression();
    jj_consume_token(VERTICAL_BAR);
    z = expression();
    jj_consume_token(71);
          ExpressionNode en =  new ExpressionNode(kernel, new MyVec3DNode(kernel, x, y, z));
          en.setLabel(l.image.substring(0,l.image.length()-1));
          {if (true) return en;}
    throw new Error("Missing return statement in function");
  }

/**
 * polarvector_special =  <LABEL>( expression ; expression ) 
 */
  final public ExpressionNode polarvector_special() throws ParseException {
   Token l;
    ExpressionValue r, phi;
    l = jj_consume_token(FUNCTION_LABEL);
    r = expression();
    jj_consume_token(POLAR_SEPARATOR);
    phi = expression();
    jj_consume_token(71);
            MyVecNode v = new MyVecNode(kernel);
            v.setPolarCoords(r, phi);
          ExpressionNode en =  new ExpressionNode(kernel, v);
          en.setLabel(l.image.substring(0,l.image.length()-1));
          {if (true) return en;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(EQUAL_BOOLEAN)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(FUNCTION_POWER_LABEL)) return true;
    if (jj_3R_36()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) return true;
    }
    return false;
  }

  private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) return true;
    }
    return false;
  }

  private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(8)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) return true;
    }
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_3R_77()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_78()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(Z_FUNC)) return true;
    if (jj_3R_36()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) return true;
    }
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_68()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    }
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_scan_token(SQRT_SHORT)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(Y_FUNC)) return true;
    if (jj_3R_36()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) return true;
    }
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_scan_token(FACTORIAL)) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_3R_20()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_70()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_3R_74()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_75()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(X_FUNC)) return true;
    if (jj_3R_36()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) return true;
    }
    return false;
  }

  private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(73)) return true;
    if (jj_3R_20()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_69()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(74)) return true;
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_scan_token(FACTORIAL)) return true;
    return false;
  }

  private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    }
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_3R_79()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_3R_23()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_scan_token(UNDEFINED)) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_scan_token(INFINITY)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_scan_token(FUNCTION_LABEL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_50()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) return true;
    }
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(FUNCTION_LABEL)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(POLAR_SEPARATOR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_scan_token(IMAGINARY)) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_scan_token(E)) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(IMPLICATION)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_scan_token(EULER_GAMMA)) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_3R_45()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_46()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_scan_token(FUNCTION_LABEL)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(VERTICAL_BAR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(VERTICAL_BAR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_scan_token(PI)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    return false;
  }

  private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(RAD)) return true;
    return false;
  }

  private boolean jj_3R_26() {
    if (jj_scan_token(FUNCTION_LABEL)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(VERTICAL_BAR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_scan_token(DEGREE)) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_scan_token(POWER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_scan_token(POWERN)) return true;
    return false;
  }

  private boolean jj_3R_123() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) return true;
    }
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_scan_token(PERCENTAGE)) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_3R_76()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_123()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(75)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(POLAR_SEPARATOR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(POLAR_SEPARATOR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_124() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) return true;
    }
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_112() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    }
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(75)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(POLAR_SEPARATOR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) return true;
    }
    if (jj_3R_30()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_51()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(71)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) return true;
    }
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_103() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_scan_token(SPREADSHEET_LABEL)) return true;
    if (jj_scan_token(70)) return true;
    if (jj_scan_token(SPREADSHEET_LABEL)) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_scan_token(75)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(75)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(VERTICAL_BAR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(VERTICAL_BAR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    }
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(DIVIDE)) return true;
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_71()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_113()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_30() {
    if (jj_scan_token(75)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(75)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(VERTICAL_BAR)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(DIVIDE)) return true;
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_3R_103()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_104()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) return true;
    }
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) return true;
    }
    }
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_20()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) return true;
    }
    }
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(VARZ)) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) return true;
    }
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind != VERTICAL_BAR;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_32()) return true;
    }
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_101()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(VARY)) return true;
    return false;
  }

  private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(VARX)) return true;
    return false;
  }

  private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_43()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(71)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    if (jj_3R_23()) return true;
    xsp = jj_scanpos;
    if (jj_3R_44()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_scan_token(IS_ELEMENT_OF)) return true;
    if (jj_3R_80()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_3R_80()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_24()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_scan_token(SET_DIFFERENCE)) return true;
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(73)) return true;
    if (jj_3R_22()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_73()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(74)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_94()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_95()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    }
    return false;
  }

  private boolean jj_3_28() {
    if (jj_scan_token(73)) return true;
    if (jj_scan_token(74)) return true;
    return false;
  }

  private boolean jj_3R_98() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) return true;
    }
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_97()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_98()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_scan_token(TEXT)) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3_25() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_scan_token(VERTICAL_BAR)) return true;
    if (jj_3R_23()) return true;
    if (jj_scan_token(VERTICAL_BAR)) return true;
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_scan_token(PERPENDICULAR)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_20()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_scan_token(75)) return true;
    if (jj_3R_36()) return true;
    if (jj_scan_token(71)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_20()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(GREATER_EQUAL)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_scan_token(LESS_EQUAL)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(GREATER)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(LESS)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_102() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_scan_token(IS_SUBSET_OF_STRICT)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(FUNCTION_LABEL)) return true;
    if (jj_3R_36()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_72()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) return true;
    }
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(IS_SUBSET_OF)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_scan_token(RANDOM_FUNC)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(NOT_EQUAL)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_3R_102()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[67];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x20,0x20,0x1000020,0x1,0x60,0x60,0x1,0x1,0x1,0x1,0x0,0x0,0x6000180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000020,0x0,0x0,0x0,0x60,0x800,0x1000000,0x400,0x200,0xfdb000,0xfdb000,0x6000000,0x6000000,0x20000,0x4000,0x60000000,0x60000000,0x80000000,0x80000000,0x6000180,0x10000000,0x6000000,0x6000000,0x10000000,0x180,0x100,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3040000,0x3070000,0xf33f37f3,0x8000,0x0,0x8000,0x8000,0x3040000,0x40000000,0x3070000,0x8000,0x0,0x8000,0x40000000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf33f37f3,0x4,0x0,0x0,0x4,0xf33f37f3,0x1,0xf33f37f3,0x3837f2,0x0,0x8000,0x0,0x3000000,0x70000,0x3000000,0x180000,0x380000,0x3807f2,0x0,0x0,0x0,0x0,0x8000,0x0,0xf0000000,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x40,0x40,0x0,0x1,0x40,0x40,0x1,0x1,0x1,0x1,0x0,0x0,0xa1e,0x0,0x180,0x0,0x0,0x200,0x4,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1e,0x0,0x0,0x0,0x0,0xa1e,0x0,0xa1c,0x0,0x10,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x180,0x180,0x180,0x180,0x0,0x180,0xc,0x800,0x800,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[31];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[76];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 67; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 76; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 31; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
